# 融合式架构设计：为 Phase 2 智能体预留扩展接口

为了兼顾“Phase 1 的快速落地”与“Phase 2 的智能体扩展”，我们将在后端引入 **"Chat Processor (对话处理器)"** 的设计模式。这相当于在 Controller 和 RAGFlow 之间插入了一个可插拔的“大脑”。

## 1. 架构核心：处理器模式 (The Processor Pattern)

我们不把代码写死为“直接调用 RAGFlow”，而是抽象出一个处理流程：

```java
// 核心接口设计
public interface ChatProcessor {
    // 输入：用户上下文、问题、历史记录
    // 输出：流式响应
    Flux<AiResponse> process(UserContext context, String query);
}
```

* **Phase 1 (当前)**: 实现 `RagDirectProcessor`。

  * 逻辑：查权限 -> 组装参数 -> 透传给 RAGFlow。

  * *特点：简单、直通。*

* **Phase 2 (未来)**: 实现 `AgentOrchestratorProcessor`。

  * 逻辑：调用大模型 (Intent Recognition) -> 判断意图。

  * *分支 A (查资料)*: 转发给 `RagDirectProcessor`。

  * *分支 B (执行任务)*: 调用 `SkillExecutor` (运行 Python 脚本) -> 返回结果。

## 2. 数据库设计的预留 (Database Extensibility)

为了支撑 Phase 2，我们需要在现有 2 张表的基础上，预留 Skill 相关的定义能力（无需现在实现，但表结构要兼容）：

1. **用户与权限表 (Phase 1 必需)**

   * `t_user`: 用户基础信息

   * `t_permission`: 资源授权表

     * 字段 `resource_type`: 区分是 `RAG_DATASET` (知识库) 还是 `AGENT_SKILL` (技能)。

     * 字段 `resource_id`: 对应 ID。

     * *设计意图*: 同一张表，既能管知识库权限，也能管未来“谁能用质检工具”的权限。

2. **技能定义表 (Phase 2 预留)**

   * `t_skill`: 定义工具有哪些

     * `name`: 工具名 (e.g., "质检工具")

     * `trigger_intent`: 触发意图描述

     * `script_path`: Python 脚本路径

     * `params_schema`: 参数定义 (JSON)

## 3. 开发执行计划 (Revised for Extensibility)

### 步骤 1: 模块化工程搭建

* 建立 `backend` 工程。

* **关键解耦**: 创建 `rag-client` (负责与 RAGFlow 通信) 和 `skill-engine` (负责未来跑脚本) 两个独立 Package。

### 步骤 2: 统一鉴权与通用接口

* 定义通用的 `/api/chat` 接口。

* 实现 `UserContext` 解析器 (Mock/Header模式)。

* **关键**: 在 Controller 层使用 `ChatProcessor` 接口，而非具体的实现类。通过配置 (`@ConditionalOnProperty`) 决定当前启用哪个 Processor。

### 步骤 3: 默认处理器实现 (Phase 1)

* 实现 `RagDirectProcessor`。

* 完成 `t_permission` 的 CRUD 接口 (Admin)。

* 完成 RAGFlow 原生接口的透传逻辑。

### 步骤 4: 验证扩展性 (无需开发 Phase 2，但做验证)

* 写一个简单的 Mock Skill Processor，证明在不修改 Controller 代码的情况下，可以通过配置切换到“智能体模式”。

***

## 4. 详细数据库设计 (Database Detailed Design)

### 4.1 用户表 (`t_user`)

用于存储简单的用户信息，作为业务解耦的锚点。

| 字段名           | 类型          | 约束           | 说明                  |
| :------------ | :---------- | :----------- | :------------------ |
| `id`          | BIGINT      | PK, AI       | 用户主键                |
| `username`    | VARCHAR(64) | UK, Not Null | 用户名（唯一业务标识）         |
| `role`        | VARCHAR(20) | Not Null     | 角色：`admin` / `user` |
| `create_time` | DATETIME    | Default Now  | 创建时间                |

```sql
CREATE TABLE t_user (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(64) NOT NULL UNIQUE COMMENT '用户名',
    role VARCHAR(20) NOT NULL DEFAULT 'user' COMMENT '角色',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP
) COMMENT '用户表';
```

### 4.2 权限表 (`t_permission`)

核心表，用于定义“谁”可以访问“什么资源”。资源可以是 RAG 知识库，也可以是 Phase 2 的 Skill。

| 字段名             | 类型          | 约束          | 说明                                  |
| :-------------- | :---------- | :---------- | :---------------------------------- |
| `id`            | BIGINT      | PK, AI      | 主键                                  |
| `user_id`       | BIGINT      | Not Null    | 关联 `t_user.id`                      |
| `resource_type` | VARCHAR(20) | Not Null    | 资源类型：`DATASET` (知识库), `SKILL` (技能)  |
| `resource_id`   | VARCHAR(64) | Not Null    | 资源ID（RAGFlow Dataset ID 或 Skill ID） |
| `create_time`   | DATETIME    | Default Now | 授权时间                                |

```sql
CREATE TABLE t_permission (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    resource_type VARCHAR(20) NOT NULL COMMENT '资源类型: DATASET/SKILL',
    resource_id VARCHAR(64) NOT NULL COMMENT '外部资源ID',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    UNIQUE KEY uk_user_resource (user_id, resource_type, resource_id)
) COMMENT '权限关联表';
```

## 5. 详细接口设计 (API Interface Design)

### 5.1 Admin 管理接口 (供前端管理台使用)

**1. 获取所有知识库列表 (透传 RAGFlow)**

* **URL**: `GET /api/admin/datasets`

* **逻辑**: Java 后端直接调用 RAGFlow API，返回所有知识库供管理员选择。

* **Response**:

  ```json
  {
    "code": 0,
    "data": [
      { "id": "kb-001", "name": "测绘规范库", "doc_count": 10 },
      { "id": "kb-002", "name": "内部档案库", "doc_count": 5 }
    ]
  }
  ```

**2. 用户授权**

* **URL**: `POST /api/admin/permission/grant`

* **Body**:

  ```json
  {
    "username": "zhangsan",
    "resource_type": "DATASET",
    "resource_id": "kb-001"
  }
  ```

* **逻辑**: 在 `t_permission` 表中插入一条记录。

**3. 获取用户权限列表**

* **URL**: `GET /api/admin/permission/{username}`

* **Response**:

  ```json
  {
    "code": 0,
    "data": [ "kb-001", "kb-003" ] // 返回该用户已授权的 Dataset IDs
  }
  ```

### 5.2 User 聊天接口 (供前端聊天界面使用)

**1. 发起对话 (SSE 流式)**

* **URL**: `POST /api/chat/completions`

* **Headers**:

  * `X-User-Name`: `zhangsan` (由网关或前端透传，Phase 1 模拟鉴权)

* **Body**:

  ```json
  // 发给 RAGFlow 的请求
  {
    "question": "水准测量限差是多少？",
    "dataset_ids": ["kb-001"], // <--- 注入点：仅允许访问授权库
    "stream": true
  }
  ```

* **后端处理逻辑 (RagDirectProcessor)**:

  1. 解析 Header 获取当前用户 `zhangsan`。
  2. 查询 `t_user` 找 ID，再查 `t_permission` 获取该用户所有 `DATASET` 类型的 `resource_id` 列表（例如 `['kb-001']`）。
  3. **关键步骤**: 构造 RAGFlow 请求，**强制注入** `dataset_ids` 字段。

     ```json
     // 发给 RAGFlow 的请求
     {
       "question": "水准测量限差是多少？",
       "dataset_ids": ["kb-001"], // <--- 注入点：仅允许访问授权库
       "stream": true
     }
     ```
  4. 接收 RAGFlow 的 SSE 流，透传给前端。

* **Response (SSE)**:
  与 RAGFlow 原生格式保持一致，前端可直接复用现有组件。

  ```text
  data: { "answer": "...", "reference": { "chunks": [...] } }
  ```
